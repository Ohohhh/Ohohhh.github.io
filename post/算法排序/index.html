<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.55.6" />

  <title>八大算法排序(Java) &middot; Ohohhh&#39;s blog</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://ohohhh.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://ohohhh.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://ohohhh.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://ohohhh.github.io/img/favicon.ico" type="image/x-icon" />

  
    
        <link rel="stylesheet" href="https://ohohhh.github.io/css/my.css">
    
  
  
    
        <script src="https://ohohhh.github.io/js/my.js"></script>
    
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://ohohhh.github.io/">Menu</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/topics/"><i class='fa fa-folder fa-fw'></i>Topics</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://weibo.com/5954877907" rel="me" target="_blank"><i class="fa fa-weibo fa-fw"></i>Weibo</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/Ohohhh" rel="me" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>八大算法排序(Java)</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>11 Sep 2019, 21:15</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://ohohhh.github.io/topics/%E7%AE%97%E6%B3%95">算法</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://ohohhh.github.io/tags/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F">八大排序</a>
    
  </div>
  
  

</div>

  

<h2 id="八大排序算法-java">八大排序算法（Java）</h2>

<p><strong>内排序：</strong>在排序过程中，所有元素调到内存中进行的排序，称为内排序。内排序是排序的基础。内排序效率用比较次数来衡量。</p>

<p><strong>外排序：</strong>在数据量大的情况下，只能分块排序，但块与块间不能保证有序。外排序用读/写外存的次数来衡量其效率。</p>

<p>$$
\begin{cases}
内部排序
\begin{cases}
插入排序
\begin{cases}
直接插入排序
\希尔排序
\end{cases}
\选择排序
\begin{cases}
简单选择排序
\堆排序
\end{cases}
\交换排序
\begin{cases}
冒泡排序
\快速排序
\end{cases}
\归并排序
\基数排序
\end{cases}
\
<br />
外部排序
\end{cases}
$$</p>

<p>下面八种排序均属于内部排序，内部排序主要消耗时间复杂度，而外部排序消耗的是空间复杂度。</p>

<h4 id="直接插入排序">直接插入排序：</h4>

<pre><code class="language-java">/**
 * 直接插入排序：从第一个（认为已排序）开始，
 * 取下一个元素依次与前面已排元素比较并插入到合适位置（当新元素&gt;=已排序元素中的某个元素 就把新元素放到该元素的后面）
 */
public class Insertion_sort {
    public static void main(String[] args) {
        int[] arr = new int[]{2,4,9,0,5,1};
        for (int i = 0; i &lt; arr.length-1; i++) {
            int current = arr[i+1];
            int preindex = i;
            // 当当前元素小于已排元素时，已排序每一位向后移
            while (preindex &gt;= 0 &amp;&amp; current &lt; arr[preindex]){
                arr[preindex+1] = arr[preindex];  
                preindex--;
            }
            // 否则就插入进去
            arr[preindex+1] = current;  
        }
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>

<h4 id="希尔排序">希尔排序：</h4>

<pre><code class="language-java">/**
 * 希尔排序：插入排序的增强版 分组过后进行插入比较，可优先比较远的元素
 */
public class Shell_sort {
    public static void main(String[] args) {
        int[] arr = new int[]{2, 5, 4, 1, 7, 0};
        int len = arr.length;
        int gap = len / 2;
        // 结束标志为不能再分组的时候
        while (gap &gt; 0) {
            for (int i = gap; i &lt; len; i++) {
                int temp = arr[i];
                // 前面各元素的索引
                int preIndex = i - gap;
                // 当当前元素小于已排元素时，每组元素向后移动步长位 步长为gap
                while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; temp) {
                    arr[preIndex + gap] = arr[preIndex];  
                    preIndex -= gap;
                }
                // 否则插入进去
                arr[preIndex + gap] = temp;  
            }
            // 再次分组
            gap /= 2;  
        }
       System.out.println(Arrays.toString(arr));
    }
}
</code></pre>

<h4 id="简单选择排序">简单选择排序：</h4>

<pre><code class="language-java">/*
    选择排序：先找到最小数放到第一个，再依次向后找最小数，并保存索引，放到前一个最小数后面
 */
public class Selection_sort {
    public static void main(String[] args) {
        int[] arr = new int[]{2,4,7,9,0,1};
        for (int i = 0; i &lt; arr.length; i++) {
            // 先认为第一个最小
            int mindex = i;
            // 后面的比较 i之前是比较完成的
            for (int j = i; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[mindex]) {
                    // 修改最小值索引
                    mindex = j;
                }
            }
            // 交换位置  
            int temp = arr[mindex];
            arr[mindex] = arr[i];
            arr[i] = temp;

        }
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>

<h4 id="堆排序">堆排序:</h4>

<pre><code class="language-java">/**
 * 堆排序：把堆调整为最大堆（按照升序和降序选择），把堆顶节点与尾节点交换位置，再调整为最大堆，以此循环。
 */
public class Heap_sort {
    public static void main(String[] args) {
        int[] arr =  new int[]{2,5,3,6,1,9,0};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void heapSort(int[] arr){
        // 从最后一个非叶子节点开始
        int start = (arr.length-1)/2;
        // 调整为最大堆
        for (int i = start; i &gt;=0; i--) {
            maxHeap(arr,arr.length,i);
        }
        // 循环交换第0个和最后一个位置然后再重新调整最大堆
        for(int i = arr.length-1; i&gt;0; i--){
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            maxHeap(arr,i,0);
        }
    }
    public static void maxHeap(int[] arr, int size, int index){  // index为当前节点的索引
        // 左子节点
        int leftNode = 2*index + 1;
        // 右子节点
        int rightNode = leftNode +1;
        // 默认当前节点最大
        int max = index;
        // 比较找出最大节点
        if (leftNode&lt;size&amp;&amp;arr[leftNode]&gt;arr[max]){
            max = leftNode;
        }
        if (rightNode&lt;size&amp;&amp;arr[rightNode]&gt;arr[max]){
            max = rightNode;
        }
        // 如果当前节点不是最大值，则将当前节点与最大值交换，并且再次调整堆结构。
        if (max != index){
            int temp = arr[index];
            arr[index] = arr[max];
            arr[max] = temp;
            maxHeap(arr, size, max);
        }
    }
}
</code></pre>

<h4 id="冒泡排序">冒泡排序：</h4>

<pre><code class="language-java">/*
    冒泡排序：前后两个依次比较 大的往后移
 */
public class Bubble_sort {
    public static void main(String[] args) {
        int[] arr = new int[]{3,4,1,6,9,0};
        // 需要比较的轮数
        for (int i = 0; i &lt; arr.length; i++)
             //  一轮需要比较的次数
            for (int j = 0; j &lt; arr.length-1-i; j++)
                //  交换位置，大的后移
                if (arr[j+1] &lt; arr[j]){
                    int temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>

<h4 id="快速排序">快速排序：</h4>

<pre><code class="language-java">/**
 * 快速排序： 找一个基准数pivot 把大的放它右边 小的放它左边  再递归地把它分好的的子列快速排序
 */
public class Quick_sort {
    public static void main(String[] args) {
        int[] arr = new int[]{2, 4, 6, 1, 9, 0};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int start, int end) {
        // 递归结束标志
        if (start &lt; end) {
            // 把第一个设为基准数
            int pivot = arr[start];
            // 设置左右两边下标
            int left = start;
            int right = end;
            // 基准数没重合之前 左边下标始终小于右边下标
            while (left &lt; right) {
                // 因为设置的基准数为第一个所以先把右边的数和基准数比较
                // 当右边的数大于等于基准数时，下标左移 比较下一个
                while (left &lt; right &amp;&amp; arr[right] &gt;= pivot) {
                    right--;
                }
                // 比基准数小时与左边的数交换位置
                arr[left] = arr[right];
                // 当左边的数小于等于基准数时下标右移，比较下一个
                while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) {
                    left++;
                }
                // 比基准数大时与右边的数交换位置
                arr[right] = arr[left];
            }
            // 比较完成下标重合 把下标替换成基准数
            arr[left] = pivot;
            // 递归处理子列
            quickSort(arr, start, left - 1);
            quickSort(arr, left + 1, end);
        }
    }
}
</code></pre>

<h4 id="归并排序">归并排序：</h4>

<pre><code class="language-java">/**
 * 归并排序: 把序列平分成两个，再对子列进行归并排序，最后对归并好的两个子列合并成一个。
 */
public class Merge_sort {
    public static void main(String[] args) {
        int[] array = new int[]{2, 5, 6, 3, 7, 0};
        System.out.println(Arrays.toString(cutting(array)));
    }

    // 递归切割成两个
    private static int[] cutting(int[] array) {
        if (array.length &lt;= 1) {
            return array;
        }
         // 右移一位相当于除以2
        int mid = array.length &gt;&gt; 1; 
        // 左闭右开
        int[] left = Arrays.copyOfRange(array,0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
        return merge(cutting(left), cutting(right));
    }

    // 合并两个排序后的子列
    private static int[] merge(int[] left, int[] right) {
        // 用于存放最后结果
        int[] result = new int[left.length + right.length];  
        for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {
            // 处理左边有多余的情况
            if (i &gt;= left.length)  
                result[index] = right[j++];
            // 处理右边有多余的情况
            else if (j &gt;= right.length)  
                result[index] = left[i++];
            // 左右两边分别比较 放入小的一个
            else if (left[i] &gt; right[j])
                result[index] = right[j++];
            else
                result[index] = left[i++];
        }
        return result;
    }
}
</code></pre>

<h4 id="基排序">基排序:</h4>

<pre><code class="language-java">/**
 * 基数排序:找到最大数，计算位数，从最低位开始按照每位数字进行分组，每组再计数排序。
 */
public class Radix_sort {
    public static void main(String[] args) {
        int[] array =  new int[]{2,3,6,1,7,0};
        radix(array);
        System.out.println(Arrays.toString(array));
    }

    private static void radix(int[] array) {
        // 找到最大数并计算位数表示要比较的轮数
        int max = array[0];
        for (int i = 0; i &lt; array.length; i++) {
            if (max&lt;array[i]){
                max = array[i];
            }
        }
        int maxLength = (max + &quot;&quot;).length();
        // new个二维数组用于临时存放
        int[][] temp = new int[10][array.length];
        // 记录每组存放的个数
        int[] counts = new int[10];
        // 共循环轮数
        for (int i = 0, n = 1; i &lt; maxLength; i++, n*=10) {
            // 循环存值
            for (int j = 0; j &lt; array.length; j++) {
                // 计算余数
                int ys = array[j] / n % 10;
                temp[ys][counts[ys]] = array[j];
                counts[ys]++;
            }
            // 取出临时数组的值存放
            int index = 0;
            for (int k = 0; k &lt; counts.length; k++) {
                if (counts[k] != 0) {
                    for (int l = 0; l &lt; counts[k]; l++) {
                        array[index] = temp[k][l];
                        index++;
                    }
                    // 一组完了把数量归零
                    counts[k] = 0;
                }
            }
        }
    }
}
</code></pre>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://ohohhh.github.io/post/%E9%9A%8F%E7%AC%94/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://ohohhh.github.io/post/%E9%9A%8F%E7%AC%94/">随笔</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'Ohohhh';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="https://ohohhh.github.io/js/ui.js"></script>
<script src="https://ohohhh.github.io/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking ID', 'auto');
    ga('send', 'pageview');
  }
</script>





</body>
</html>

