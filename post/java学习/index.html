<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.55.6" />

  <title>Java学习 &middot; Ohohhh&#39;s blog</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://ohohhh.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://ohohhh.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://ohohhh.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://ohohhh.github.io/img/favicon.ico" type="image/x-icon" />

  
    
        <link rel="stylesheet" href="https://ohohhh.github.io/css/my.css">
    
  
  
    
        <script src="https://ohohhh.github.io/js/my.js"></script>
    
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://ohohhh.github.io/">Menu</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/topics/"><i class='fa fa-folder fa-fw'></i>Topics</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ohohhh.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://weibo.com/5954877907" rel="me" target="_blank"><i class="fa fa-weibo fa-fw"></i>Weibo</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/Ohohhh" rel="me" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Java学习</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>05 Sep 2019, 16:46</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://ohohhh.github.io/topics/java">Java</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://ohohhh.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Java基础学习笔记</a>
    
  </div>
  
  

</div>

  

<h2 id="问题处理">问题处理</h2>

<p><strong>double型数字运算丢失精度问题：</strong></p>

<pre><code class="language-java">double a = 0.05;
double b = 0.07;
double c = a + b;
System.out.println(c);  // 0.12000000000000001
</code></pre>

<p>原因：这是因为计算机内部是用的是二进制码，当我们输入float或者double类型的十进制数的时候，会先转化成二进制数再进行运算，最后在转化为十进制输出。然而有些数字不能完全转化成二进制，计算机只能将结果<strong>无限趋近</strong>于原本十进制的数值，故会出现精度丢失的问题。</p>

<p>解决：使用<code>BigDecimal</code>类 ，float和double属于非精准浮点数，decimal属于精准浮点数。</p>

<p><strong>Tomcat乱码问题</strong>：</p>

<ol>
<li>找到conf/logging.properties</li>
<li>添加语句：<code>java.util.logging.ConsoleHandler.encoding = GBK</code></li>
</ol>

<p><strong>Servlet 找不到路径404问题:</strong></p>

<p>​   不要把servlet文件 放在名为servlet包下面 这样解析不出来就404</p>

<p><strong>读取文件找不到真实路径问题：</strong></p>

<p>​   &ldquo;/WEB-INF/classes/敏感词汇.txt&rdquo;</p>

<p><strong>Mysql插入不了中文数据问题:</strong></p>

<p>在MySQL的安装目录下找到my.ini, 找到[mysqld]，[client] 做如下修改</p>

<p><code>[mysqld]
character-set-server=utf8 
[client]
default-character-set=utf8</code></p>

<h2 id="基础知识">基础知识</h2>

<p><strong>字节</strong>：计算机最小存储单元。8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。</p>

<p><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，，我们编写的Java代码，都运行在 JVM 之上。</p>

<p><strong>JRE</strong> (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。</p>

<p><strong>JDK</strong> (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。</p>

<p>配置环境变量：</p>

<ol>
<li>点击系统变量的 新建 ，创建新的环境变量，变量名输入 JAVA_HOME ，变量值输入JDK9的安装目录</li>
<li>选中 Path 环境变量，点击新建，键入%JAVA_HOME%\bin</li>
</ol>

<p><strong>标识符</strong>：在程序中我们自己定义内容 ，比如类、方法、变量的名字。</p>

<ul>
<li>不能是关键字</li>
<li>不能以数字开头</li>
<li>以字母、数字、$美元符号、_下划线组成</li>
</ul>

<p><strong>常量</strong>：整数常量、小数常量、布尔常量、字符常量、字符串常量、空常量。
字符常量用单引号引起来 ，且必须有内容不能为空。</p>

<p>变量定义格式：</p>

<pre><code class="language-java">数据类型 变量名 = 数据值；
</code></pre>

<p><strong>Java数据类型</strong>：</p>

<p>基本数据类型：整数、浮点数、字符、布尔
引用数据类型：类、数组、接口</p>

<p>Java中的字符串String属于引用数据类型。因为String是一个类，底层是由数组构成。</p>

<p>数据转换：范围小的向范围大的类型转，<code>byte</code>,<code>short</code>,<code>char</code>运算时会自动向<code>int</code>转</p>

<blockquote>
<p>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</p>
</blockquote>

<p>+= 是一个运算符，只运算一次，并带有强制转换的特点， 也就是说 s += 1 就是 s = (short)(s + 1)</p>

<pre><code class="language-java">short s = 1;
s += 1; // s = (short)(s+1)
s = s + 1; // (s+1)为int--&gt;s为short   发生数据转换错误
</code></pre>

<p>混合运算时，++a 先自加1 再赋值， a++ 先赋值再自加1，独立运算时无影响。</p>

<p>三元运算符格式：</p>

<p><code>数据类型 变量名 = 布尔类型表达式？ 结果1：结果2</code></p>

<p>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。</p>

<p>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</p>

<p>break 使用场景：终止switch或者循环。switch中由于case存在穿透性，所以要写break。
continue 使用场景：结束本次循环，继续下一次的循环。</p>

<p>IDEA快捷键：</p>

<table>
<thead>
<tr>
<th><code>Alt+enter</code></th>
<th>导入包，自动修正代码</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Ctrl+Y</code></td>
<td>删除光标所在行</td>
</tr>

<tr>
<td><code>Ctrl+D</code></td>
<td>复制光标所在行的内容，插入光标位置下面</td>
</tr>

<tr>
<td><code>Ctrl+Alt+L</code></td>
<td>按规范格式化代码</td>
</tr>

<tr>
<td><code>Ctrl+/</code></td>
<td>注释代码</td>
</tr>

<tr>
<td><code>Ctrl+Shift+/</code></td>
<td>选中代码注释，多行注释，再按取消注释</td>
</tr>

<tr>
<td><code>Alt+Ins</code></td>
<td>自动生成代码，toString，get，set等方法</td>
</tr>

<tr>
<td><code>Alt+Shift+上下箭头</code></td>
<td>移动当前代码行</td>
</tr>

<tr>
<td><code>Ctrl+r</code></td>
<td>批量修改名字</td>
</tr>

<tr>
<td><code>Alt +shift +T</code></td>
<td>批量选中代码</td>
</tr>

<tr>
<td><code>Ctrl+鼠标左键</code></td>
<td>查看源码</td>
</tr>

<tr>
<td><code>ctrl+n</code></td>
<td>查找类</td>
</tr>
</tbody>
</table>

<p><strong>方法重载(overload)</strong>：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表(参数个数或参数类型)不同即可，与修饰符和返回值类型无关 。</p>

<p><strong>方法重写（override）</strong>: 子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即<strong>声明不变，重新实现</strong>！。</p>

<p><strong>Java三大特性：</strong></p>

<p><strong>封装：</strong>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>

<p><strong>继承：</strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。继承可以拥有父类中所有方法和属性(包括私有的)，但是仅仅是拥有无法访问。</p>

<p><strong>多态：</strong>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>

<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>

<p>JVM内存划分：</p>

<table>
<thead>
<tr>
<th>区域</th>
<th align="left">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>寄存器</td>
<td align="left">给CPU使用，和我们开发无关</td>
</tr>

<tr>
<td>本地方法栈</td>
<td align="left">JVM在使用操作系统功能的时候使用，和我们开发无关。</td>
</tr>

<tr>
<td>方法区</td>
<td align="left">存储可以运行的class文件    线程共享</td>
</tr>

<tr>
<td>方法栈</td>
<td align="left">方法运行时使用的内存，比如main方法运行，进入方法栈中执行。线程私有</td>
</tr>

<tr>
<td>堆内存</td>
<td align="left">存储对象实例或者数组，new来创建的，都存储在堆内存。线程共享</td>
</tr>

<tr>
<td>栈内存</td>
<td align="left">栈内存只包含原始值变量和堆中对象变量的引用。线程私有</td>
</tr>
</tbody>
</table>

<h2 id="数组">数组</h2>

<p>数组格式：</p>

<p><code>数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度]</code></p>

<p><code>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...}</code></p>

<p><code>数据类型[] 数组名 = {元素1,元素2,元素3...}</code></p>

<p><strong>数组和集合的区别</strong>：</p>

<ol>
<li>数组声明了它容纳的元素的类型，而集合不声明。集合存储的都是对象。而且对象的类型可以不一致。</li>
<li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求。</li>
</ol>

<p>数组的工具类 ：Arrays类</p>

<p><code>Arrays.toString(arr)</code>  数组内容转为字符串</p>

<p><code>Arrays.sort(arr)</code>  升序排序</p>

<h2 id="类与对象">类与对象</h2>

<p><strong>面向对象与面向过程的区别</strong>：
    面向对象强调的是通过调用对象的行为来实现功能，而面向过程需要一步一步去实现。</p>

<p>类与对象的关系</p>

<ul>
<li>类是一组相关<strong>属性</strong>和<strong>行为</strong>的集合是对一类事物的描述，是抽象的。</li>
<li>对象是一类事物的实例，是具体的。</li>
<li>类是对象的模板，对象是类的实体。</li>
</ul>

<p><strong>Java创建对象的过程：</strong></p>

<ol>
<li>类加载检查 ：类加载之前虚拟机会先检查new指令的参数引用所代表的类是否已经被加载、解析、初始化过。</li>
<li>分配内存：类加载检查通过之后，虚拟机为新对象分配内存。（分配内存的两种方式：指针碰撞和空闲列表）。</li>
<li>初始化零值：将分配到的内存空间初始化零值（不包括对象头），保证了对象实例可以不赋初值就可以使用，访问的是默认初始零值。</li>
<li>设置对象头：对象头里包含了一些头信息，如该对象是那个类的实例，如何找到该类的元数据信息，该对象的哈希码等都放在对象头中。</li>
<li>执行init方法：当为对象按照自己的意愿初始化时执行，如为对象起别名。</li>
</ol>

<p><strong>成员变量与局部变量的区别</strong>：</p>

<ol>
<li><p>在类中的位置不同 。成员变量：类中，方法外， 局部变量：方法中或者方法声明上(形式参数）</p></li>

<li><p>作用范围不一样。 成员变量：类中 局部变量：方法中</p></li>

<li><p>初始化值的不同。  成员变量：有默认值 局部变量：没有默认值。必须先定义，赋值，最后使用</p></li>

<li><p>生命周期不同 。</p></li>
</ol>

<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p>

<p>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</p>

<p>当成员变量用<code>private</code>关键字修饰时，本类中可提供set/get方法来访问私有变量，其中<code>this.成员变量</code> 为了解决形参和成员变量重名导致的成员变量被隐藏问题，从而无法赋值。</p>

<p><strong>Scanner类的使用</strong>：</p>

<pre><code class="language-java">Scanner sc = new Scanner(System.in);
System.out.println(&quot;请输入一个数字：&quot;)；
int a = sc.nextInt();
</code></pre>

<p><strong>Random类的使用：</strong></p>

<pre><code class="language-java">Random r = new Random();
int a = r.nextInt(10);  // 随机生成[0,10)的整数
</code></pre>

<p><strong>工具类Math类的使用：</strong></p>

<pre><code class="language-java">Math.abs(-5)  // 返回绝对值
Math.ceil(5.5)  // 返回&gt;=5.5的最小整数
Math.floor(5.5)  // 返回&lt;=5.5的最大整数
Math.round(5.5) // 四舍五入
</code></pre>

<h2 id="string">String</h2>

<p>java.lang.String 类代表字符串。</p>

<p><code>public final class String</code></p>

<p>特点：</p>

<ol>
<li>字符串的值在创建后不能被更改。</li>
</ol>

<pre><code class="language-java">String str = &quot;abc&quot;;
str += &quot;d&quot;; 
System.out.println(str);  // abcd
//  内存中有abc  和  abcd 两个对象  上面只是改变了str的指向并没有改变abc对象的值
</code></pre>

<ol>
<li>String值不能修改 final修饰的，可以共享。</li>
</ol>

<pre><code class="language-java">String str1 = &quot;a&quot;;
String str2 = &quot;a&quot;;
// 内存中只有一个&quot;a&quot;对象被创建，但是被str1和str2所共享
</code></pre>

<ol>
<li>String底层是数组，所以其为引用类型</li>
</ol>

<pre><code class="language-java"> String str = &quot;abc&quot;; 
相当于：
char data[] = {'a', 'b', 'c'}; 
String str = new String(data); 
// String底层是靠字符数组实现的。
</code></pre>

<p><strong>StringBuffer 和 StringBuilder的区别：</strong></p>

<p>StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。</p>

<p>常用方法：</p>

<ul>
<li><code>public int length ()</code>：返回此字符串的长度。</li>
<li><code>public String concat (String str)</code>：将指定的字符串连接到该字符串的末尾。</li>
<li><code>public char charAt (int index)</code>：返回指定索引处的 char值。</li>
<li><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</li>
<li><code>public String substring (int beginIndex)</code>：返回一个子字符串，从beginIndex开始截取字符串到字符 串结尾。</li>
<li><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到 endIndex截取字符串。含beginIndex，不含endIndex。</li>
<li><code>public char[] toCharArray ()</code>：将此字符串转换为新的字符数组。</li>
<li><code>public byte[] getBytes ()</code> ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li>
<li><code>public String replace (CharSequence target, CharSequence replacement)</code>：将与target匹配的字符串使 用replacement字符串替换。</li>
<li><code>public String[] split(String regex,int limit)</code>：将此字符串按照给定的regex（正则表达式规则）拆分为字符串数组，limit 为分割的次数。</li>
</ul>

<h2 id="static和abstract">static和abstract</h2>

<p><strong>static</strong>:用来修饰的成员变量和成员方法，被修饰的成员是<strong>属于类</strong>的，而不是单单是属 于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p>

<p>static 修饰的内容： 是随着类的加载而加载的，且只加载一次存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。</p>

<p>静态方法中，不能使用this关键字。static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问</p>

<p>在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。</p>

<p>静态代码块：定义在成员位置，使用static修饰的代码块{ }。</p>

<p>位置：类中方法外。 随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</p>

<p><strong>abstract</strong>:使用 abstract关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体,所以抽象类中不需要创建对象。
抽象方法 ： 没有方法体的方法。抽象类：包含抽象方法的类。
继承抽象类的子类必须重写父类所有的抽象方法。</p>

<h2 id="collection">Collection</h2>

<p><strong>集合</strong>
顶层：Collection 不带索引 所以遍历需要用迭代器Iterator</p>

<p>list和set 是Collection的接口 所以不能new</p>

<ul>
<li>list：可重复 有索引 有顺序的</li>
<li>set：无重复  无索引不能使用普通for循环遍历 用增强for</li>
</ul>

<p>List的子类：<code>ArrayList</code> , <code>LinkedList</code></p>

<p>ArrayList 和LinkedList 的区别：</p>

<ol>
<li>底层数据结构：ArrayList底层为数组，LinkedList底层为双向链表。</li>
<li>快速随机访问：ArrayList访问快，LinkedList增删快。</li>
<li>内存空间占用：ArrayList底层为动态数组，会预留一定的容量空间，LinkedList则是在每个元素还要储存前驱和后继导致的空间浪费。</li>
<li>插入删除的影响：ArrayList插入删除复杂度大概为O(n),受位置影响。LinkedList则近等于O(1),不受位置影响。</li>
<li>都是不同步，他们都是线程不安全的。需要线程安全可使用Vector类取代ArryList，它的所有方法都是同步的，只是在一个线程访问时会浪费大量时间在同步操作上。</li>
</ol>

<p>java.util.ArrayList 是大小<strong>可变的数组</strong>的实现，称为集合类。</p>

<p>构造格式：</p>

<p><code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code></p>

<p>E为泛型，可替换成你所用的<strong>引用类型</strong></p>

<p>常用方法：</p>

<ul>
<li><code>public boolean add(E e)</code>：将指定的元素添加到此集合的尾部。</li>
<li><code>public E remove(int index)</code> ：移除此集合中指定位置上的元素。返回被删除的元素。</li>
<li><code>public E get(int index)</code>：返回此集合中指定位置上的元素。返回获取的元素。</li>
<li><code>public int size()</code>：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</li>
</ul>

<p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 <strong><int></strong> 不能写，但是存储基本数据类型对应的 包装类型是可以的。</p>

<p>只有int-&gt; Integer 和 char&gt;Character 需要特殊记忆，其他基本类型只是首字母大写即可。</p>

<p>set的子类：<code>Hashset</code> , <code>LinkedHashSet</code></p>

<p>给HashSet中存放自定义类型元素时，需要<strong>重写对象中的hashCode和equals方法</strong>，建立自己的比较方式，才能保 证HashSet集合中的对象唯一。</p>

<p>可参考：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>

<p>HashSet保证元素唯一，可是元素存放进去是没有顺序的
为了保证有序使用 LinkedHashSet ，它是链表和哈希表组合的一个数据存储结构</p>

<p><strong>可变参数</strong></p>

<p>如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格 式：</p>

<p><code>修饰符 返回值类型 方法名(参数类型... 形参名){ }</code></p>

<p>这个书写完全等价与</p>

<p><code>修饰符 返回值类型 方法名(参数类型[] 形参名){ }</code></p>

<p>但是可以省去创建数组的步骤直接传值</p>

<p><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。
一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。
泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</p>

<h2 id="map">Map</h2>

<p>Collection 中的集合称为单列集合， Map 中的集合称为双列集合。 需要注意的是， Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</p>

<p>Map 的子类：<code>HashMap</code>集合、<code>LinkedHashMap</code>、<code>HashTable</code>集合。</p>

<p><strong>HashMap</strong>：内部实现为数组+链表+红黑树（jdk1.8增加的），链表的存在是为了解决哈希冲突，当链表长度大于8时转为红黑树。元素的存取顺序不能保证一致,，允许键一次为null，值多次为null。由于要保证键的唯一、不重复，需 要重写键的hashCode()方法、equals()方法。 非线程安全(保证线程安全使用ConcurrentHashMap)。</p>

<p><strong>HashTabel</strong>：和HashMap大同小异，主要差异在于HashTable不允许键或值为null不然会报空指针异常。加了同步代码块，线程安全，但效率低下，被舍弃。</p>

<p><strong>LinkedHashMap</strong>：HashMap的子类，存储数据采用的哈希表结构+链表结构。通过链 表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。</p>

<p><strong>ConcurrentHashMap(分段锁)</strong>:与HashTable不同的是这里采用分段式加锁来解决线程安全问题，保证了并发操作下的线程安全。JDK1.8之后取消了Segment分段锁，采用CAS和synchronized来保证并发下线程安全，只锁定链表或红黑二叉树首节点效率更高。</p>

<p>常用方法：</p>

<p><code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。</p>

<p><code>public V remove(Object key)</code> : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的</p>

<p>值。</p>

<p><code>public V get(Object key)</code>: 根据指定的键，在Map集合中获取对应的值。</p>

<p><code>public Set&lt;K&gt; keySet()</code> : 获取Map集合中所有的键，存储到Set集合中。</p>

<p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)，通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示: getkey() getValue() 。</p>

<p><strong>of（）方法：</strong></p>

<p>of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等； 2:返回的集合是不可变的 所以不能再add 等操作!</p>

<h2 id="多线程">多线程</h2>

<p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</p>

<p><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</p>

<p><strong>进程是操作系统分配资源的单位。</strong></p>

<p><strong>线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。</strong></p>

<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p>

<p>实现Runnable接口比继承Thread类所具有的优势：</p>

<ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>

<p><strong>同步问题</strong>：当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p>

<p><strong>同步代码块</strong>： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>

<p>格式:</p>

<pre><code class="language-java">synchronized(同步锁){ 

需要同步操作的代码 

} 
</code></pre>

<p><strong>Lock 锁</strong>:</p>

<p><code>public void lock()</code>:加同步锁。</p>

<p><code>public void unlock()</code> :释放同步锁。</p>

<p><strong>线程池</strong>：</p>

<pre><code class="language-java">//1.创建线程池对象。
ExecutorService pool =Executors.newFixedThreadPool(2);
//2.创建Runnable接口子类对象。
(task)ThreadPollDemo task = new ThreadPollDemo();
// 从线程池中获取线程对象,然后调用MyRunnable中的run()方法
pool.submit(task);
pool.submit(task);
pool.submit(task);
pool.shutdown();// 关闭线程池
</code></pre>

<p><strong>Lambda</strong>:</p>

<p>格式：</p>

<p><code>(参数类型 参数名称) ‐&gt; { 代码语句 }</code></p>

<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。</li>
<li>方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>

<h2 id="file-类">File 类</h2>

<ul>
<li><code>public String getAbsolutePath()</code>：返回此File的绝对路径名字</li>
<li><code>public String getPath()</code>：将此File转换为路径名字符串。</li>
<li><code>public String getName()</code>：返回由此File表示的文件或目录的名称。</li>
<li><code>public long length()</code>：返回由此File表示的文件的长度。</li>
<li><code>public boolean exists()</code>：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code>：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code>：此File表示的是否为文件。</li>
<li><code>public boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</li>
<li><code>public boolean delete()</code>：删除由此File表示的文件或目录。 删除目录时目录要为空才能删除</li>
<li><code>public boolean mkdir()</code>：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
<li><code>public String[] list()</code>：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
<li><code>public File[] listFiles()</code>：返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>

<h2 id="io">Io</h2>

<p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>

<p><strong>输入流</strong> ：把数据从 其他设备 上读取到 内存 中的流。</p>

<p><strong>输出流</strong> ：把数据从 内存 中写出到 其他设备 上的流。</p>

<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>

<p><strong>字节流</strong> ：以字节为单位，读写数据的流。</p>

<p><strong>字符流</strong> ：以字符为单位，读写数据的流。   用法类似</p>

<p><strong>java.io.FileOutputStream</strong> 类是文件输出流，用于将数据写出到文件。</p>

<pre><code class="language-java">// 使用文件名称创建流对象 
FileOutputStream f = new FileOutputStream(&quot;f.txt&quot;);
</code></pre>

<ol>
<li><strong>写出数据</strong>：： write(int b) 方法，每次可以写出一个字节数据</li>
<li><strong>写出字节数组</strong>： write(byte[] b) ，每次可以写出数组中的数据</li>
</ol>

<pre><code class="language-java">FileOutputStream fos = new FileOutputStream(&quot;f.txt&quot;);
byte[]  b =&quot;好好学习&quot;.getBytes();
fos.write(b);
fos.close();
</code></pre>

<ol>
<li><strong>追加数据</strong>:public FileOutputStream(File file/String name, boolean append)  创建文件输出流以写入由指定的 File对象或文件名字表示的 文件。 参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示清空原有数据。</li>
</ol>

<pre><code class="language-java">FileOutputStream f = new FileOutputStream(&quot;f.txt&quot;,true);
f.write(&quot;\r\n&quot;.getBytes());  // 追加换行符
</code></pre>

<p><strong>java.io.FileInputStream</strong> 类是文件输入流，从文件中读取字节。</p>

<pre><code class="language-java">// 使用文件名称创建流对象
FileInputStream fis = new FileInputStream(&quot;s.txt&quot;);
</code></pre>

<ol>
<li><strong>读取字节</strong>： read 方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回 -1</li>
</ol>

<pre><code class="language-java">int read = fis.read(); 
System.out.println((char) read);
// 循环读取
int b;
while ((b = fis.read())!=‐1) { System.out.println((char)b); }
</code></pre>

<ol>
<li><strong>使用字节数组读取</strong>： read(byte[] b) ，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读 取到末尾时，返回 -1 ，</li>
</ol>

<pre><code class="language-java">int len ； 
// 定义字节数组，作为装字节数据的容器 
byte[] b = new byte[2]; 
// 循环读取
while (( len= fis.read(b))!=‐1){ 
// 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 }
</code></pre>

<p><strong>写出字符串</strong>:</p>

<pre><code class="language-java">// 使用文件名称创建流对象 
FileWriter fw = new FileWriter(&quot;fw.txt&quot;);
// 字符串数组形式
char [] b = &quot;好好学习&quot;.toCharArray();
fw.write(b); // 好好学习
// 字符串 
String msg = &quot;天天向上&quot;;
// 写出字符数组 
fw.write(msg); //天天向上
</code></pre>

<p>缓冲流,也叫高效流，是对4个基本的 FileXxx 流的增强，所以也是4个流，按照数据类型分类：</p>

<p><strong>字节缓冲流</strong>： BufferedInputStream ， BufferedOutputStream</p>

<p><strong>字符缓冲流</strong>： BufferedReader ， BufferedWriter</p>

<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO 次数，从而提高读写的效率。</p>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://ohohhh.github.io/post/mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%9F%A5%E8%AF%A2/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://ohohhh.github.io/post/mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%9F%A5%E8%AF%A2/">Mysql基本使用之查询</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="https://ohohhh.github.io/post/%E9%9A%8F%E7%AC%94/">随笔</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="https://ohohhh.github.io/post/%E9%9A%8F%E7%AC%94/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'Ohohhh';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="https://ohohhh.github.io/js/ui.js"></script>
<script src="https://ohohhh.github.io/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking ID', 'auto');
    ga('send', 'pageview');
  }
</script>





</body>
</html>

